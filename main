#include <iostream>
#include <filesystem>
#include <string>
#include <utility>
#include <fstream>


namespace fs = std::filesystem;


/*
СУБД – система управления базами данных.
БД – совокупность объектов класса.
Запись БД – объект класса.
Однотипные БД – БД, содержащие объекты одного класса.
Гибридные БД – БД, содержащие объекты разных классов.
Через интерфейс СУБД == через взаимодействие с пользователем (с помощью ввода команды с клавиатуры).
Задание:
1. Реализовать абстрактный класс, содержащий чистые виртуальные функции,
функционал которых различается для наследников, в соответствии с вариантом и
заданной им организацией данных (группировкой).
2. Реализовать разбор текстовых команд, введённых с клавиатуры.
3. Разработать формат сохранения БД в файл.
4. Реализовать функции в соответствии с вариантом.
5. Реализовать управление базами данных через интерфейс СУБД:
5.1) Создание однотипных БД и гибридных БД.
5.2) Вывод на экран* списка существующих БД.
5.3) Удаление* БД.
5.4) Переименование* БД.
5.5) Открытие** БД.
5.6) Сохранение** БД.
5.7) Добавление записей в БД.
5.8) Редактирование записей в БД.
5.9) Удаление записей в БД.
5.10) Вывод на экран записей БД.
5.11) Сортировка записей БД.
5.12) Выборка записей БД по правилу (значению поля).
5.13) Сохранение** выборки как новой БД.

Справка. Использовать известные приёмы и технологии: типы и алгоритмы STL,
многофайловые программы, полиморфизм, исключения.
* Реализовать, используя Filesystem library.
** Работа с текстовыми файлами.
С умом подходить к реализации и сложности используемых алгоритмов, наименованию
переменных, функций, типов данных и т.д.
На сдачу присылать архив файлов с кодом + описание формата сохранения данных.

Вариант №17
БД – совокупность подразделений (организация). Класс 1 – образовательные подразделения. Класс 2 – научные
подразделения. Каждое подразделение имеет название, руководителя (ФИО), число аспирантов, число
сотрудников. У образовательных подразделений указаны проекты (название, стоимость). У научных
подразделений указано число студентов и стоимость обучения одного студента, сгруппированные по курсам.
Функции (п. 4):
-Подсчёт кол-ва студентов для каждого подразделения в БД (включая аспирантов).
-Реализовать поиск подразделения внутри БД по ФИО.
Правила сортировки записей БД (п. 5.11):
-По названию подразделения (по алфавиту).
-По числу сотрудников.
Правила выборки записей из БД (п. 5.12):
-Подразделения, где на каждого сотрудника приходится не меньше number аспирантов (numberзадаётся
с клавиатуры).
-Подразделения, где число сотрудников превышает number (number задаётся с клавиатуры).
*/

int new_file_create(std::string db_name) {                          //ф-ия для создания каталога с именем db_name с учетом возможного наличия одноименных файлов
    fs::path p;
    int a = 2;
    int i;
    p = db_name;
    std::string st1 = "1";
    db_name.insert(db_name.size(), st1);
    for (i = 1; i < a; i++) {
        if (i < 10) {
            db_name.erase(db_name.size() - 1, 1);
            st1 = std::to_string(i);
            db_name.insert(db_name.size(), st1);
            p = db_name;
            if (fs::exists(p) == true) {
                a++;
            }
            else {
                fs::create_directories(p);
            }
        }
        else {
            db_name.erase(db_name.size() - 2, 2);
            st1 = std::to_string(i);
            db_name.insert(db_name.size(), st1);
            p = db_name;
            if (fs::exists(p) == true) {
                a++;
            }
            else {
                fs::create_directories(p);
            }
        }
    }
    return i - 1;
}



class DB_core {
public:
    DB_core() {};
    virtual void add_num() {};
    virtual ~DB_core() {};

};

class Educationcomp : public DB_core{
public:
    std::string compname, bossname[3], fullname;
    int asper_num, worker_num, database_num, educationcomp_num;     //аспиранты, работники, номер дб, номер подразделения 
    std::pair< std::string[3], int > projects;
    std::string db_name = "./DB_", a;


    //Educationcomp() {};
    
};



class Sciencecomp : public DB_core {
public:
    std::string compname, bossname[3], fullname, db_name, a;
    int asper_num, worker_num, database_num, sc_num;                //Аспиранты, работники, номер дб, номер подразделения
    std::pair< int, std::pair< int, int >> student;                 //int 1 - курс, внутренний int 1 - число студентов, внутренний int 2 - стоимость
    std::ofstream workfile;                                         //Файл с записями для данной SC

    //Sciencecomp() {};
    void add_num(int sc_num1, int database_num1) {                                  //Создает основной файл для SC
        database_num = database_num1;
        sc_num = sc_num1;
        fullname = "./DB_";
        fullname.insert(fullname.size(), std::to_string(database_num));
        fullname.insert(fullname.size(), "/");
        fullname.insert(fullname.size(), "sc_");
        fullname.insert(fullname.size(), std::to_string(sc_num));
        fullname.insert(fullname.size(), ".txt");
        std::ofstream workfile(fullname);
    }

};




class Database {
public:
    std::string db_name = "./DB_";
    std::string sclistadr = "", eclistadr = "";                        //Переменная для адреса инфо-листов для научных и учебных компаний
    std::string db_username, namestring;
    int database_num = -1;
    int pos;
    bool is_bd_exist = false;
    std::vector<DB_core*> sc;                                       //Вектор научных и учебных компаний
    std::vector<Educationcomp> ec;
    std::ofstream sclist, eclist;

    Database() {};

    std::string create_DB(std::string db_username) {                   //Ф-ия создает новую БД если такой не существует
        std::ifstream namefile("Namelist.txt");                        //Список созданных БД
        if (namefile.is_open()) {                                      //Получение списка имен
            getline(namefile, namestring);
        }
        else {
            return "no file";                                          //Возврат ошибки в случает отсуствия нейм-файла
        }
        pos = namestring.find(db_username);                            //
        if (pos != std::string::npos) {                                //
            is_bd_exist = true;                                        //
            database_num = namestring[pos + db_username.size()];       //Поиск номера БД если она была создана ранее
        }
        if (is_bd_exist == false) {
            database_num = new_file_create(db_name);                   //Создает файл с нумерацией
            std::ofstream out("Namelist.txt", std::ios::app);          //Проверка на нейм-файл не осуществляется т.к. была до этого
            out << db_username << database_num << ";";                 //Добавление в нейм-файл имени и номера БД
            is_bd_exist = true;

            sclistadr = db_name;                                       //"Сборка" полного адреса нейм-файла для SC
            std::string a = std::to_string(database_num);              //
            sclistadr.insert(sclistadr.size(), a);                     //
            sclistadr.insert(sclistadr.size(), "/scinfo.txt");         //

            eclistadr = db_name;                                       //"Сборка" полного адреса нейм-файла для EC
            std::string z = std::to_string(database_num);              //
            eclistadr.insert(eclistadr.size(), a);                     //
            eclistadr.insert(eclistadr.size(), "/ecinfo.txt");         //

            std::ofstream sc_namelist(sclistadr);                      //Создание нейм-файлов для SC и EC
            std::ofstream ec_namelist(eclistadr);                      //
            return "success";
        }
        else {
            return "db exists";                                        //В случае существования БД с заданным именем - возвращает ошибку
        };
    };

    std::string open_DB(std::string db_username) {                     //Ф-ия проверяет, существует ли БД и находит её номер
        std::ifstream namefile("Namelist.txt");                        //Список созданных БД
        if (namefile.is_open()) {                                      //Получение списка имен
            getline(namefile, namestring);
        }
        else {
            return "no file";                                          //Возврат ошибки в случает отсуствия нейм-файла
        }
        pos = namestring.find(db_username);                            //
        if (pos != std::string::npos) {                                //
            is_bd_exist = true;                                        //
            database_num = namestring[pos + db_username.size()];       //Поиск номера БД если она была создана ранее
        }
        else {
            return "db dose not exist";
        }

    };

    std::string add_sc(std::string sc_name) {
        if (is_bd_exist == true) {

            sc.resize(sc.size()+1);
            
            int i = sc.size() - 1;
            //sc[i].add_num(i + 1);
            return "success";
        }
        else {
            return "fail";
        }
    };

    void add_ec() {
        
    };
};









int main()
{
    std::string result;
    Database db1;
    db1.create_DB("Base2_");
    db1.add_sc("sc1");
    /*std::string a1("./DB_1/info.txt");
    std::ofstream f1(a1);*/
    int a = 1, b = 2;
    Sciencecomp sc1;
    std::vector<DB_core*> v1;
    v1.push_back(new Sciencecomp);
    v1[0]->add_num(1);
    sc1.add_num(a, b);
    return 0;
}
